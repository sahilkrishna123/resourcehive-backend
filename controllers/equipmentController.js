import cron from "node-cron";
import Equipment from "../models/equipmentModel.js";

import MaintenanceHistory from "../models/maintenanceHistoryModel.js";
import Prediction from "../models/predictionModel.js";
import AppError from "../utils/appError.js";
import { catchAsync } from "../utils/catchAsync.js";
import * as factory from "./handlerFactory.js";
import mongoose from "mongoose";

// Define normal ranges for each parameter
const normalRanges = {
  Tidal_Volume: [400, 600],
  Respiratory_Rate: [12, 20],
  Peak_Pressure: [15, 30],
  FiO2: [21, 55],
  Temperature: [20, 37],
  Humidity: [20, 100],
};

// In-memory data storage for recent monitoring data
const inMemoryData = new Map();

export const createEquipment = factory.createOne(Equipment);
export const getOneEquipment = factory.getOne(Equipment);
export const getAllEquipments = factory.getAll(Equipment);
export const deleteEquipment = factory.deleteOne(Equipment);
export const updateEquipment = catchAsync(async (req, res, next) => {
  const { hospitalId, equipmentId } = req.params;
  const criteria = { hospitalId, equipmentId };
  

  const doc = await Equipment.findOneAndUpdate(criteria, req.body, {
    new: true,
    runValidators: true,
  });

  if (!doc) {
    return next(new AppError("No document found with that ID", 404));
  }

  res.status(200).json({
    status: "success",
    data: { data: doc },
  });
});

// Function to monitor real-time data with alerts
async function monitorData(equipmentId, operationalData) {
  // Extract the time value as the last element in operationalData
  const time = operationalData[operationalData.length - 1];

  // Check if time is greater than 5 seconds
  if (time <= 5) {
    console.log(
      "Time is less than or equal to 5 seconds; skipping malfunction check."
    );

    // Store non-critical data in memory
    inMemoryData.set(equipmentId, {
      ...operationalData,
      timestamp: new Date(),
    });
    console.log("Logged Memory", inMemoryData);

    return;
  }

  const parameterKeys = [
    "Tidal_Volume",
    "Respiratory_Rate",
    "Peak_Pressure",
    "FiO2",
    "Temperature",
    "Humidity",
  ];
  const outOfRangeParams = [];

  operationalData.forEach((value, index) => {
    const param = parameterKeys[index];
    if (normalRanges[param]) {
      const [min, max] = normalRanges[param];
      const isOutOfRange = value < min || value > max;
      if (isOutOfRange) {
        outOfRangeParams.push(param);
      }
    }
  });

  console.log(outOfRangeParams);

  if (outOfRangeParams.length > 0) {
    console.log(
      `Malfunction detected for parameters: ${outOfRangeParams.join(", ")}`
    );
    const timestamp = new Date();

    // Save alert for malfunctions in maintenance collection
    const alert = await MaintenanceHistory.create({
      // maintenanceId is auto generated by mongoose
      equipmentId,
      maintenanceType: "Urgent",
      timestamp,
    });
    console.log("Alert:", alert);

    // Save prediction for malfunction
    const malfunctionPrediction = await Prediction.create({
      equipmentId,
      predictedFailureDate: timestamp,
      // predictionAccuracy: 1, // Set to 1 for detected malfunctions // Remove it in future
      predictedIssue: "Malfunction",
    });
    console.log("malfunctionPrediction: ", malfunctionPrediction);
  } else {
    // Will not be executed
    // Store non-critical data in memory
    // inMemoryData.set(equipmentId, {
    //   ...operationalData,
    //   timestamp: new Date(),
    // });
    // console.log("Logged Memory", inMemoryData);
  }
}

// IoT Data Route to process incoming data
export const processIotData = catchAsync(async (req, res, next) => {
  const { operationalData } = req.body;
  const { udiNumber } = req.params;

  const currentEquipment = await Equipment.findOne({ udiNumber: udiNumber });
  // console.log(currentEquipment._id.toString());

  await monitorData(currentEquipment._id.toString(), operationalData);

  // Decide response in future
  res.status(200).json({ message: "Data processed successfully." });
});

// Cron job to clear old in-memory data every 30 mins
// cron.schedule("*/30 * * * *", () => {
//   const currentTime = new Date().getTime();
//   const thirtyMinutes = 30 * 60 * 1000;

//   for (const [equipmentId, data] of inMemoryData) {
//     if (currentTime - data.timestamp.getTime() > thirtyMinutes) {
//       inMemoryData.delete(equipmentId);
//     }
//   }
//   // Log the current contents of inMemoryData
//   console.log("Current inMemoryData contents:");
//   for (const [equipmentId, data] of inMemoryData) {
//     console.log(`Equipment ID: ${equipmentId}, Data:`, data);
//   }
//   console.log(
//     "Cleared old in-memory data if any data was older than 30 minutes."
//   );
// });

// // Cron job to clear old in-memory data every 15 seconds

// cron.schedule("*/15 * * * * *", () => {
//   // Run every 15 seconds
//   const currentTime = new Date().getTime();
//   // const thirtyMinutes = 30 * 60 * 1000; // 30 minutes in milliseconds
//   const thirtyMinutes = 15 * 1000; // 10 seconds in milliseconds

//   for (const [equipmentId, data] of inMemoryData) {
//     if (currentTime - data.timestamp.getTime() > thirtyMinutes) {
//       inMemoryData.delete(equipmentId);
//     }
//   }
//   // Log the current contents of inMemoryData
//   console.log("Current inMemoryData contents:");
//   for (const [equipmentId, data] of inMemoryData) {
//     console.log(`Equipment ID: ${equipmentId}, Data:`, data);
//   }
//   console.log(
//     "Cleared old in-memory data if any data was older than 15 seconds."
//   );
// });
